#include <stdio.h>
#include <iostream>
#include <string>
#include <fstream>
#include <sstream>
#include <math.h>
#include <limits>

int max(int x, int y, int z) {
	int flagx = x;
	if (y > flagx) {flagx = y;}
	if (z > flagx) {flagx = z;} 
	return flagx;
}

void get_uv(std::ifstream in, std::ofstream dsm, int uv){
    in.clear();
    in.seekg(0, std::ios::beg);
    int cnt=0;
	std::string line;
    while (getline(in, line))
    {
        if (line.substr(0,3) == "vt ")
        {
            cnt++;
            if(cnt==uv){
			    std::istringstream s(line.substr(3));
                float u, v;
                s >> u; s >> v;
                // todo: get to uv off and write
			    dsm << ".short " << int(round(u*4095)) << ", " << int(round(v*4095)) << "\n";        
            }
		}

	}


}

int main(int argc, char* argv[]){
	long ap, vp, hp;
	int junk=1;
	printf("obj2kh2v\n-- If you don't know what a VIF packet be prepared to be driven to insanity\n\n");
	if(argc<2){printf("Usage: obj2kh2v model.obj"); return -1;}
	std::ifstream input(argv[1], std::ios::in);
	std::string dsmname = std::string(argv[1]).substr(0,std::string(argv[1]).find_last_of('.'))+".dsm";
	std::string kh2vname = std::string(argv[1]).substr(0,std::string(argv[1]).find_last_of('.'))+".kh2v";
	std::ofstream dsm (dsmname);
	dsm << ".align 0\n;" << argv[1] << "\n;Automatically generated by obj2kh2v\n;DO NOT EDIT IF YOU DON'T KNOW WHAT YOU ARE DOING\n\nstcycl 01, 01; We write code to memory without skips/overwrite\n\nunpack[r] V4_32, 0, *; Model Part Header\n.int 1, 0, 0, 0;type 1 Model\n";
	hp = dsm.tellp();
	//Can't insert if not at eof using ofstream so I put 10 spaces to fill up, size of INT_MAX and no \n to avoid linefeed not beeing rewritten
	//It's so hacky but I'm fed up with this shit already
	dsm << "     " << "          ,           ,           ,                                                                                                                                                                                                                                                                                                           ";
dsm << "\n.EndUnpack\n\nstcycl 01, 01; We write code to memory without skips/overwrite\n\nunpack[r] V2_16, 4, *; UV definition\n";
	int vi =0;
	int ti =0;
    int face_count=0;
    int vert_count=0;
    // max uv buffer, should be enough for an entire set of obj vertices
    int uvs[8192];

	if (dsm.is_open()){
	std::string line;
    while (getline(input, line))
    {
        if (line.substr(0,2) == "v ")
        {
			vi++;
        }
    }
    input.clear();
    input.seekg(0, std::ios::beg);
    while (getline(input, line))
    {
        if (line.substr(0,2) == "f ")
        {
			face_count++;
        }
    }
    input.clear();
    input.seekg(0, std::ios::beg);

    int y=0;
    while (getline(input, line))
    {
        if (line.substr(0,3) == "vt ")
        {
			std::istringstream s(line.substr(3));
			float u, v;
            s >> u; s >> v;
			printf("tx= %f, ty= %f, txr= %d, tyr=%d\n", u, v, int(round(u*4095)), int(round(v*4095)));		
            uvs[y]=int(round(u*4095));
            uvs[y+1]=int(round(v*4095));
            y+=2;
		}

	}
    input.clear();
    input.seekg(0, std::ios::beg);

    long uv_pos = dsm.tellp();
    // get uv pos here
    for(int i=0; i<face_count;i++){
        // temporary uvs to rewrite below
         dsm << "                              ";        
         dsm << "                              ";        
         dsm << "                              ";        
    }
    
    input.clear();
    input.seekg(0, std::ios::beg);


		dsm << "\n.EndUnpack\n\nstmask 0xcfcfcfcf; Sets mask register(3303, check EEUSER_E)\nstcycl 01, 01; We write code to memory without skips/overwrite\n\nunpack[r] S_8, 4, *; Vertex indices\n";
    while (getline(input, line))
    {
        if (line.substr(0,2) == "f ")
        {
            long cur_pos=0;
	        std::istringstream s(line.substr(2));
			std::string i, n, u;
			int ii, inn, iu;
            s >> i; s >> n; s >> u;
			ii = std::stoi(i.substr(0, i.find("/"))); 			
			inn = std::stoi(n.substr(0, n.find("/"))); 			
			iu = std::stoi(u.substr(0, u.find("/"))); 			
			printf("i1: %d i2: %d i3: %d\n", ii, inn, iu);		
            dsm << ".byte " << ii-1 << "\n";
            cur_pos=dsm.tellp();
            dsm.seekp(uv_pos);
            dsm << ".short " << uvs[(ii-1)*2] << ", " << uvs[((ii-1)*2)+1] << "\n";
            uv_pos=dsm.tellp();
            dsm.seekp(cur_pos);

            dsm << ".byte " << inn-1 << "\n";
            cur_pos=dsm.tellp();
            dsm.seekp(uv_pos);
            dsm << ".short " << uvs[(inn-1)*2] << ", " << uvs[((inn-1)*2)+1] << "\n";
            uv_pos=dsm.tellp();
            dsm.seekp(cur_pos);

            dsm << ".byte " << iu-1 << "\n";
            cur_pos=dsm.tellp();
            dsm.seekp(uv_pos);
            dsm << ".short " << uvs[(iu-1)*2] << ", " << uvs[((iu-1)*2)+1] << "\n";
            uv_pos=dsm.tellp();
            dsm.seekp(cur_pos);
			printf("bis i1: %d i2: %d i3: %d\n", (ii-1)*2, (inn-1)*2, (iu-1)*2);		

            vert_count+=3;
        }
    }

dsm << ".EndUnpack\n\nstmask 0x3f3f3f3f; Sets mask register(3330, check EEUSER_E)\nstcycl 01, 01; We write code to memory without skips/overwrite\n\nunpack[r] S_8, 4, *; Flags\n";
        for(int i=0; i<face_count; i++){
            long pos = dsm.tellp();
			dsm << ".byte 0x10; stock\n"; 
			dsm << ".byte 0x10; stock\n"; 
            dsm << ".byte 0x20; draw triangle\n";
        }
dsm << ".EndUnpack\n\nstcol 0x3f800000, 0x3f800000, 0x3f800000, 0x3f800000; We set garbage data to 1(float) so even if nothing is referenced game doesn't go crazy\nstmask 0x80808080; Sets mask register(0002, check EEUSER_E)\nstcycl 01, 01; We write code to memory without skips/overwrite\n\nunpack[r] V3_32,";
vp = dsm.tellp();
dsm << "               , *; Vertex definition\n";

input.clear();
input.seekg(0, std::ios::beg);

  while (getline(input, line))
    {
        if (line.substr(0,2) == "v ")
        {
			std::istringstream s(line.substr(2));
			float x, y, z, w;
            s >> x; s >> y; s >> z; w = 1.0f;
			dsm << ".float " << x << ", " << y << ", " << z << "\n";

        }
}


dsm << ".EndUnpack\n\nstcycl 01, 01; We write code to memory without skips/overwrite\n\nunpack[r] V4_32,";
ap = dsm.tellp();
dsm << "          , *; Vertex affiliation header\n.int " << vi << ", 0, 0, 0\n.EndUnpack\nvifnop\nvifnop; We wait for data to be kicked in\n";

}
printf("h1: %i, h2: 4, h3: %i, h4: %i\nj1: %i, j2: %i, j3: 0, j4: 1\n",ti, 4+ti+vi, 4+ti+vi+1,vi, 4+ti);
		//TODO: Stop hardcode Header size(5type-line exist) and Vert/Array
		//h3: 1 not because 1 value but 1 array of 4, padding needs to be
		//checked!
#if (_WIN32)
		dsm.seekp(hp+10);
#else
		dsm.seekp(hp);
#endif
		dsm << ".int " << face_count*3 << ", 4, " << 4+(face_count*3)+vi << ", " << 4+(face_count*3)+vi+1 << "; Number of u+v+flag+index, their offset, offset of vertex affiliation header, offset of mat definition(end)\n";
		dsm << ".int 0, 0, 0, 0; Nobody care about vertices merging and colors\n";
        dsm << ".int " << vi << ", " << 4+(face_count*3) << ", 0, 1; Number of vertices, their offset, reserved and number of array attribution\n";
#if (_WIN32)
		dsm.seekp(vp+10);
#else
		dsm.seekp(vp);
#endif
		dsm << 4+(face_count*3);
#if (_WIN32)
		dsm.seekp(ap+10);
#else
		dsm.seekp(ap);
#endif
		dsm << 4+(face_count*3)+vi;
		dsm.close();
#if (_WIN32)
	if(system(("dvp-as \""+dsmname+"\" -o junk.o").c_str()) != 0){printf("Could not proceed, please install homebrew ps2 sdk!\n"); return -1;}
		if(system(("dvp-objcopy -O binary junk.o \""+kh2vname+"\"").c_str()) != 0){printf("Your homebrew ps2 sdk installation seems to be broken, please reinstall\n"); return -1;}
#else
	if(system(("dvp-as "+dsmname+" -o junk.o > /dev/null").c_str()) != 0){printf("Could not proceed, please install homebrew ps2 sdk!\n"); return -1;}
		if(system(("dvp-objcopy -O binary junk.o "+kh2vname+" > /dev/null").c_str()) != 0){printf("Your homebrew ps2 sdk installation seems to be broken, please reinstall\n"); return -1;}

#endif
		remove("junk.o");
		if(!junk){remove(dsmname.c_str());}
		return 1;
}
